# ğŸ“”IntroducciÃ³n a la ProgramaciÃ³n

## ğŸ“–Â¿QuÃ© es Python y porquÃ© aprenderlo

Python es un lenguaje de programaciÃ³n interpretado y orientado a objetos desarrollado por Guido van Rossum en la dÃ©cada de 1980. Es unido al sistema operativo Unix y se utiliza para crear aplicaciones, scripts, proyecciones y ediciones grÃ¡ficas.

**CaracterÃ­sticas clave de Python:**

1. **InterpretaciÃ³n**: Python es un lenguaje de programaciÃ³n interpretado, lo que significa que no se compila antes de ejecutarse.
2. **Orientado a objetos**: Python utiliza conceptos orientados a objetos (OO) para crear programas mÃ¡s estructurados y seguros.
3. **Simplicidad**: La sintaxis de Python es simple y fÃ¡cil de entender, lo que la hace accesible a programadores de todos los niveles.
4. **LibrerÃ­as extensas**: Python tiene una gran cantidad de librerÃ­as extensas que simplifican el desarrollo de aplicaciones y proyectos.

**Por quÃ© estudiar Python?**

1. **Aplicaciones prÃ¡cticas**: Python es una de las lenguajes de programaciÃ³n mÃ¡s populares para la creaciÃ³n de aplicaciones web, programaciÃ³n de bases de datos, anÃ¡lisis de datos, inteligencia artificial y mÃ¡s.
2. **Desarrollo web**: Python es un lenguaje ideal para el desarrollo de aplicaciones web dinÃ¡micas, gracias a las bibliotecas como Django y Flask.
3. **ProgramaciÃ³n de bases de datos**: Python es utilizado para la creaciÃ³n de aplicaciones de programaciÃ³n de bases de datos, como SQLAlchemy y PySQLAlchemy.
4. **AnÃ¡lisis de datos**: Python es una herramienta popular para el anÃ¡lisis de datos, gracias a bibliotecas como Pandas, NumPy y Matplotlib.
5. **Ciencia de los datos**: Python se utiliza en la ciencia de los datos para la creaciÃ³n de modelos estadÃ­sticos, algoritmos de aprendizaje automÃ¡tico y mÃ¡s.
6. **Desarrollo de aplicaciones mÃ³viles**: Python es una opciÃ³n popular para el desarrollo de aplicaciones mÃ³viles, gracias a frameworks como Kivy y Buildozer.

**Beneficios del estudio de Python:**

1. **Aprendizajes prÃ¡cticos**: El estudio de Python te enseÃ±arÃ¡ a programar de manera efectiva y a entender los conceptos fundamentales de la programaciÃ³n.
2. **Diversidad de aplicaciones**: La experiencia con Python te permitirÃ¡ explorar diversas Ã¡reas de interÃ©s, desde la web hasta el anÃ¡lisis de datos y mÃ¡s.
3. **Flexibilidad**: El lenguaje de Python es muy versÃ¡til y se puede utilizar para una amplia variedad de proyectos.

En resumen, estudiar Python te permitirÃ¡ aprender a programar de manera efectiva, a crear aplicaciones prÃ¡cticas y a entender los conceptos fundamentales de la programaciÃ³n.

## ğŸ“–IntroducciÃ³n al modo interactivo de Python

El **modo interactivo de Python** es una de las maneras mÃ¡s rÃ¡pidas y sencillas de trabajar con el lenguaje. Es Ãºtil para aprender, probar fragmentos de cÃ³digo o realizar cÃ¡lculos rÃ¡pidos. A continuaciÃ³n, se presenta una introducciÃ³n detallada:

------

### ğŸ“ƒ**Â¿QuÃ© es el modo interactivo?**

El modo interactivo es una interfaz en la que puedes escribir cÃ³digo de Python lÃ­nea por lÃ­nea, recibir retroalimentaciÃ³n inmediata y ver el resultado de cada instrucciÃ³n. Funciona como una calculadora avanzada y permite explorar el lenguaje de manera prÃ¡ctica.

------

### ğŸ“ƒ**CÃ³mo acceder al modo interactivo**

1. **Desde la terminal o lÃ­nea de comandos:**

   - Abre la terminal (en Linux o macOS) o el sÃ­mbolo del sistema (en Windows).

   - Escribe `python` o `python3` y presiona Enter.

   - VerÃ¡s algo como esto:
   
     En windows
   
     ![](https://i.ibb.co/5k3FpK5/image.png)
   
     En Linux
   
     ![](https://i.ibb.co/DKSywrz/image.png)

2. **Desde entornos de desarrollo integrados (IDE):**
- Muchos IDEs como PyCharm, VSCode o IDLE tienen consolas interactivas integradas.

------

### ğŸ“ƒ**CaracterÃ­sticas principales**

- **EjecuciÃ³n inmediata:** Cada instrucciÃ³n que ingresas se ejecuta al instante y muestra el resultado.

  ```less
  >>> 2 + 2
  4
  ```

- **ExploraciÃ³n rÃ¡pida:** Puedes probar funciones, mÃ©todos y estructuras de datos fÃ¡cilmente.

  ```less
  >>> "Hola".upper()
  'HOLA'
  >>> len([1, 2, 3])
  3
  ```

- **Autocompletado y ayuda integrada:**

  - Utiliza 

    ```
    help()
    ```

     para obtener informaciÃ³n sobre funciones, clases o mÃ³dulos.

    ```
    >>> help(print)
    ```
    
  - Con teclas como `Tab`, puedes autocompletar nombres de mÃ©todos o variables (disponible en REPL mejorados como IPython).

------

### ğŸ“ƒ**Ejemplos bÃ¡sicos**

1. **Usar Python como calculadora:**

   ```
   >>> 5 * 8
   40
   >>> (10 + 5) / 2
   7.5
   ```

2. **Definir variables y funciones:**

   ```
   >>> x = 10
   >>> y = 20
   >>> x + y
   30
   >>> def suma(a, b):
   ...     return a + b
   ...
   >>> suma(3, 5)
   8
   ```

3. **Probar estructuras de control:**

   ```
   >>> for i in range(3):
   ...     print(i)
   ...
   0
   1
   2
   ```

4. **Importar mÃ³dulos:**

   ```
   >>> import math
   >>> math.sqrt(16)
   4.0
   ```

------

### ğŸ“ƒ**Ventajas del modo interactivo**

- Ideal para aprender y experimentar con Python.
- Facilita la depuraciÃ³n rÃ¡pida de cÃ³digo.
- Proporciona retroalimentaciÃ³n inmediata sobre el resultado de las instrucciones.

------

### ğŸ“ƒ**Limitaciones del modo interactivo**

- No estÃ¡ diseÃ±ado para ejecutar programas largos o complejos.
- Cada vez que cierras la sesiÃ³n, las variables y funciones definidas se pierden.
- Para proyectos mÃ¡s grandes, es mejor usar archivos `.py` y ejecutarlos en el intÃ©rprete.

------

### ğŸ“ƒ**Alternativas mejoradas**

- IPython:

   Ofrece una experiencia interactiva mÃ¡s rica con caracterÃ­sticas como historial avanzado, salida mÃ¡s clara y soporte para grÃ¡ficos.

  ```
  pip install ipython
  ipython
  ```

------

â€‹	Windows

![](https://i.ibb.co/9w33GkV/image.png)

â€‹	Linux

![](https://i.ibb.co/PWjW894/image.png)

### ğŸ“ƒ**Salir del modo interactivo**

- Escribe `exit()` o usa la combinaciÃ³n de teclas `Ctrl+D` (Linux/macOS) o `Ctrl+Z` seguido de Enter (Windows).

## ğŸ“”Palabras reservadas en Python

Las palabras reservadas en Python son identificadores predefinidos que tienen un significado especial dentro del lenguaje y no pueden ser utilizados como nombres de variables, funciones o clases. Estas palabras forman parte de la sintaxis de Python y son fundamentales para estructurar programas.

------

### ğŸ“ƒ**Lista de palabras reservadas en Python**

A continuaciÃ³n, se muestra una lista de las palabras reservadas en Python (vÃ¡lida para versiones 3.10 y posteriores):

```less
plaintextCopiarEditarFalse      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```

------

### ğŸ“ƒ**CategorÃ­as de las palabras reservadas**

1. **Valores lÃ³gicos:**
   - `True`, `False`, `None`
2. **Control de flujo:**
   - `if`, `elif`, `else`, `while`, `for`, `break`, `continue`, `pass`
3. **DeclaraciÃ³n de funciones y clases:**
   - `def`, `return`, `lambda`, `class`
4. **Manejo de excepciones:**
   - `try`, `except`, `finally`, `raise`, `assert`
5. **Operadores lÃ³gicos:**
   - `and`, `or`, `not`, `is`, `in`
6. **ManipulaciÃ³n de alcance:**
   - `global`, `nonlocal`, `del`
7. **Manejo de contexto:**
   - `with`, `as`
8. **ProgramaciÃ³n asÃ­ncrona:**
   - `async`, `await`

------

### ğŸ“ƒ**CaracterÃ­sticas importantes**

1. **Prohibido usarlas como identificadores:** Intentar utilizar una palabra reservada como nombre de una variable o funciÃ³n generarÃ¡ un error de sintaxis.

   ```less
   >>> def class():
   ...     pass
   SyntaxError: invalid syntax
   ```

2. **Sensibilidad a mayÃºsculas y minÃºsculas:** Las palabras reservadas distinguen entre letras mayÃºsculas y minÃºsculas. Por ejemplo, `True` es vÃ¡lido, pero `true` no lo es.

3. **Significado especÃ­fico:** Cada palabra reservada tiene una funciÃ³n clara dentro del lenguaje, como definir estructuras condicionales, bucles, excepciones, entre otras.

------

### ğŸ“ƒ**Ejemplo de uso**

#### **ğŸ”–Control de flujo:**

```less
if True:
    print("Esto se ejecuta")
else:
    print("Esto no se ejecutarÃ¡")
```

#### ğŸ”–**DefiniciÃ³n de funciones:**

```
def sumar(a, b):
    return a + b
```

#### ğŸ”–**Bucles:**

```less
for i in range(3):
    print(i)
```

#### **ğŸ”–Manejo de excepciones:**

```less
try:
    x = 10 / 0
except ZeroDivisionError:
    print("No se puede dividir entre cero")
```

### ğŸ“ƒ**Consulta de palabras reservadas**

Puede obtener la lista de palabras reservadas en Python utilizando el mÃ³dulo `keyword`:

```less
import keyword
print(keyword.kwlist)
```

![](https://i.ibb.co/WsRPFD4/image.png)

## ğŸ“”Operadores matemÃ¡ticos, lÃ³gicos y relacionales

### ğŸ“ƒOperadores MatemÃ¡ticos

Los operadores matemÃ¡ticos permiten realizar cÃ¡lculos bÃ¡sicos y avanzados. A continuaciÃ³n, se presentan los mÃ¡s comunes:

| Operador | DescripciÃ³n      | Ejemplo   | Resultado |
| -------- | ---------------- | --------- | --------- |
| `+`      | Suma             | `5 + 3`   | `8`       |
| `-`      | Resta            | `10 - 4`  | `6`       |
| `*`      | MultiplicaciÃ³n   | `2 * 3`   | `6`       |
| `/`      | DivisiÃ³n         | `10 / 4`  | `2.5`     |
| `//`     | DivisiÃ³n entera  | `10 // 4` | `2`       |
| `%`      | MÃ³dulo (residuo) | `10 % 3`  | `1`       |
| `**`     | PotenciaciÃ³n     | `2 ** 3`  | `8`       |

------

### ğŸ“ƒ**Operadores relacionales (de comparaciÃ³n)**

Los operadores relacionales comparan valores y devuelven un valor booleano (`True` o `False`).

| Operador | DescripciÃ³n       | Ejemplo  | Resultado |
| -------- | ----------------- | -------- | --------- |
| `==`     | Igual a           | `5 == 5` | `True`    |
| `!=`     | Diferente de      | `5 != 3` | `True`    |
| `>`      | Mayor que         | `10 > 5` | `True`    |
| `<`      | Menor que         | `3 < 8`  | `True`    |
| `>=`     | Mayor o igual que | `7 >= 7` | `True`    |
| `<=`     | Menor o igual que | `4 <= 6` | `True`    |

------

### ğŸ“ƒ**Operadores lÃ³gicos**

Los operadores lÃ³gicos permiten combinar condiciones o valores booleanos.

| Operador | DescripciÃ³n                              | Ejemplo          | Resultado |
| -------- | ---------------------------------------- | ---------------- | --------- |
| `and`    | Retorna `True` si ambos son `True`       | `True and False` | `False`   |
| `or`     | Retorna `True` si al menos uno es `True` | `True or False`  | `True`    |
| `not`    | Niega el valor booleano                  | `not True`       | `False`   |

------

### ğŸ“ƒ**Ejemplos combinados**

#### **ğŸ”–Uso de operadores matemÃ¡ticos:**

```less
x = 10
y = 3

print(x + y)  # 13
print(x % y)  # 1
print(x ** y) # 1000
```

#### ğŸ”–**Uso de operadores relacionales:**

```less
a = 5
b = 7

print(a > b)  # False
print(a <= b) # True
```

#### ğŸ”–**Uso de operadores lÃ³gicos:**

```less
x = 5
y = 10

print(x > 2 and y < 15) # True
print(x < 0 or y > 15)  # False
print(not(x == 5))      # False
```

## ğŸ“”Entrada y salida  de usuario por modo interactivo

En Python, la entrada y salida de usuario en modo interactivo permite interactuar con el programa, solicitando datos al usuario y mostrando resultados. Esto se logra principalmente con las funciones integradas `input()` para la entrada y `print()` para la salida.

------

### ğŸ“ƒ**Entrada de usuario con `input()`**

La funciÃ³n `input()` permite al usuario ingresar datos desde el teclado.

#### ğŸ“ƒ**Sintaxis bÃ¡sica:**

```python
variable = input("Mensaje al usuario: ")
```

- `input()` siempre devuelve el valor ingresado como una **cadena de texto** (tipo `str`).

#### ğŸ“ƒ**Ejemplo de uso:**

```python
nombre = input("Â¿CuÃ¡l es tu nombre? ")
print("Hola,", nombre)
```

#### ğŸ“ƒ**Convertir la entrada a otros tipos de datos:**

Si se necesita un valor numÃ©rico, es necesario convertir explÃ­citamente el valor ingresado:

```python
edad = int(input("Â¿CuÃ¡ntos aÃ±os tienes? "))
print("El prÃ³ximo aÃ±o tendrÃ¡s", edad + 1, "aÃ±os.")
```

------

### ğŸ“–**Salida de datos con `print()`**

La funciÃ³n `print()` muestra informaciÃ³n en la pantalla.

#### ğŸ“ƒ**Sintaxis bÃ¡sica:**

```python
print(valor1, valor2, ..., sep=' ', end='\n')
```

- **`sep`**: Define el separador entre valores (por defecto, un espacio `' '`).
- **`end`**: Define lo que se agrega al final de la lÃ­nea (por defecto, un salto de lÃ­nea `'\n'`).

#### ğŸ“ƒ**Ejemplos de uso:**

```python
print("Hola, mundo")  # Salida: Hola, mundo
print("Python", "es", "genial", sep="-")  # Salida: Python-es-genial
print("Fin", end="!")  # Salida: Fin!
```

------

#### ğŸ“ƒ**Ejemplo combinado: Calculadora interactiva**

Un programa que pide dos nÃºmeros y muestra la suma:

```python
print("Bienvenido a la calculadora interactiva.")
num1 = float(input("Introduce el primer nÃºmero: "))
num2 = float(input("Introduce el segundo nÃºmero: "))
suma = num1 + num2
print("La suma de los nÃºmeros es:", suma)
```

------

## **Uso avanzado de `print()` con formato**

La funciÃ³n `print()` admite el uso de cadenas formateadas para una salida mÃ¡s legible.

#### **Formato con `f-strings` (Python 3.6+):**

```python
nombre = "Ana"
edad = 25
print(f'Hola, {nombre}. Tienes {edad} aÃ±os.')
```

![](https://i.ibb.co/FXtVxt3/image.png)

#### **Formato con `str.format()`:**

```python
print("Hola, {}. Tienes {} aÃ±os.".format("Ana", 25))
```

![](https://i.ibb.co/YfFPgKq/image.png)

# ğŸ“”**Manejo de excepciones en la entrada**

Para evitar errores si el usuario ingresa datos no vÃ¡lidos, se pueden usar excepciones:

```python
try:
    numero = int(input("Introduce un nÃºmero entero: "))
    print("El doble de tu nÃºmero es:", numero * 2)
except ValueError:
    print("Por favor, introduce un nÃºmero vÃ¡lido.")
```

------

# ğŸ“”Variables y tipos de datos

### **ğŸ“–Variables y constantes**

#### ğŸ“ƒ**DefiniciÃ³n de variables**

Una **variable** es un espacio en la memoria que se utiliza para almacenar datos. En Python, las variables no necesitan ser declaradas con un tipo de dato explÃ­cito, ya que Python es un lenguaje de tipado dinÃ¡mico.

**Sintaxis bÃ¡sica:**

```python
nombre_variable = valor
```

**Ejemplo:**

```python
nombre = "Juan"
edad = 25
es_estudiante = True
```

- Reglas para nombrar variables:
  - Deben comenzar con una letra o un guion bajo (`_`).
  - No pueden empezar con un nÃºmero.
  - No pueden contener espacios ni caracteres especiales.
  - No se deben usar palabras reservadas de Python.

#### ğŸ“ƒ**Constantes**

Aunque Python no tiene una forma nativa de declarar constantes, se sigue una convenciÃ³n: usar nombres en **mayÃºsculas** para indicar que el valor no debe cambiar.

**Ejemplo:**

```python
PI = 3.14159
GRAVEDAD = 9.8
```

------

### ğŸ“–**Tipos de datos bÃ¡sicos**

Python ofrece tres tipos de datos bÃ¡sicos mÃ¡s comunes:

#### ğŸ“ƒ**NumÃ©ricos**

- **Enteros (`int`):** NÃºmeros sin decimales.

  ```python
  entero = 42
  ```

- **Flotantes (`float`):** NÃºmeros con decimales.

  ```python
  flotante = 3.14
  ```

- **Complejos (`complex`):** NÃºmeros con parte real e imaginaria.

  ```python
  complejo = 2 + 3j
  ```

#### ğŸ“ƒ**Cadenas de texto (`str`)**

- Se utilizan para almacenar texto, definido entre comillas simples (`'`) o dobles (`"`).

  ```python
  saludo = "Hola, mundo"
  ```

- Soportan operaciones como concatenaciÃ³n y repeticiÃ³n:

  ```python
  mensaje = "Hola" + " " + "Mundo"
  print(mensaje)  # Salida: Hola Mundo
  
  repetido = "Hola" * 3
  print(repetido)  # Salida: HolaHolaHola
  ```

#### ğŸ“ƒ**Booleanos (`bool`)**

- Representan valores de verdad: 

  ```
  True
  ```

   o 

  ```
  False
  ```

  .

  ```python
  es_activo = True
  print(type(es_activo))  # Salida: <class 'bool'>
  ```

------

### ğŸ“–**ConversiÃ³n de tipos de datos o "casting"**

En Python, es posible convertir un tipo de dato en otro utilizando funciones de conversiÃ³n.

#### ğŸ“ƒ**ConversiÃ³n implÃ­cita**

Python realiza conversiones automÃ¡ticas cuando no hay pÃ©rdida de informaciÃ³n:

```python
num_entero = 5
num_flotante = 2.0
resultado = num_entero + num_flotante
print(resultado)  # Salida: 7.0
```

#### ğŸ“ƒ**ConversiÃ³n explÃ­cita**

Se usa cuando es necesario transformar un tipo de dato de forma manual.

**Funciones comunes:**

- `int()`: Convierte a entero.

  ```python
  entero = int(3.7)
  print(entero)  # Salida: 3
  ```

- `float()`: Convierte a flotante.

  ```python
  flotante = float(5)
  print(flotante)  # Salida: 5.0
  ```

- `str()`: Convierte a cadena.

  ```python
  texto = str(42)
  print(texto)  # Salida: "42"
  ```

- `bool()`: Convierte a booleano.

  ```python
  valor = bool(0)
  print(valor)  # Salida: False
  ```

#### ğŸ”–**Ejemplo prÃ¡ctico de conversiÃ³n de tipos:**

```python
edad = "25"  # Cadena
edad_entera = int(edad)  # ConversiÃ³n a entero
print(edad_entera + 5)  # Salida: 30
```

------

#### ğŸ“œ**Resumen final**

- Las **variables** almacenan datos y las **constantes** se usan para valores que no cambian.
- Los **tipos de datos bÃ¡sicos** son numÃ©ricos, cadenas y booleanos.
- La **conversiÃ³n de tipos** permite transformar datos entre distintos tipos, ya sea de forma implÃ­cita o explÃ­cita. Esto es Ãºtil para operaciones entre datos de diferentes tipos.

# ğŸ“”Estructuras de control

### ğŸ“–**Condiciones: `if` y `else`**

Las estructuras condicionales permiten ejecutar diferentes bloques de cÃ³digo dependiendo de si una condiciÃ³n se cumple o no.

#### **Sintaxis bÃ¡sica:**

```python
if condiciÃ³n:
    # CÃ³digo a ejecutar si la condiciÃ³n es verdadera
else:
    # CÃ³digo a ejecutar si la condiciÃ³n es falsa
```

#### **Ejemplo bÃ¡sico:**

```python
edad = 18
if edad >= 18:
    print("Eres mayor de edad")
else:
    print("Eres menor de edad")
```

#### **Uso de `elif`:**

Se utiliza cuando hay mÃºltiples condiciones.

```python
nota = 85
if nota >= 90:
    print("Excelente")
elif nota >= 70:
    print("Aprobado")
else:
    print("Reprobado")
```

### ğŸ“–**`match` (Switch)**

A partir de Python 3.10, la declaraciÃ³n `match` permite realizar mÃºltiples comparaciones de manera mÃ¡s legible.

#### **Sintaxis bÃ¡sica:**

```python
match variable:
    case valor1:
        # CÃ³digo si variable == valor1
    case valor2:
        # CÃ³digo si variable == valor2
    case _:
        # CÃ³digo para cualquier otro caso
```

#### **Ejemplo:**

```python
opcion = 2
match opcion:
    case 1:
        print("Elegiste opciÃ³n 1")
    case 2:
        print("Elegiste opciÃ³n 2")
    case _:
        print("OpciÃ³n no vÃ¡lida")
```

### ğŸ“–**Bucle `while`**

El bucle `while` ejecuta un bloque de cÃ³digo mientras una condiciÃ³n sea verdadera.

#### **Sintaxis bÃ¡sica**

```less
while condiciÃ³n:
    # CÃ³digo a ejecutar mientras la condiciÃ³n sea verdadera
```

#### **Ejemplo bÃ¡sico**

```less
contador = 1
while contador <= 5:
    print(contador)
    contador += 1
```

#### **Bucle infinito**

Un `while` sin una condiciÃ³n de salida puede generar un bucle infinito.

```less
while True:
    entrada = input("Escribe 'salir' para terminar: ")
    if entrada == "salir":
        break
```

### ğŸ“–**Bucle `for`**

El bucle `for` se utiliza para iterar sobre elementos de una secuencia como listas, cadenas o rangos.

#### **Sintaxis bÃ¡sica:**

```python
for elemento in secuencia:
    # CÃ³digo a ejecutar por cada elemento
```

#### **Ejemplo bÃ¡sico:**

```python
frutas = ["manzana", "pera", "uva"]
for fruta in frutas:
    print(fruta)
```

#### **Uso con `range()`:**

```python
for i in range(1, 6):
    print(i)
```

### ğŸ“–**`continue`, `break` y `else` en bucles**

Estos comandos permiten controlar la ejecuciÃ³n dentro de un bucle.

#### ğŸ“ƒ**`break`:**

Finaliza el bucle de forma inmediata.

```python
for i in range(10):
    if i == 5:
        break
    print(i)
```

#### ğŸ“ƒ**`continue`:**

Omite la iteraciÃ³n actual y pasa a la siguiente.

```python
for i in range(5):
    if i == 2:
        continue
    print(i)
```

#### ğŸ“ƒ**`else`:**

El bloque `else` en un bucle se ejecuta cuando el bucle termina de forma normal (sin un `break`).

```python
for i in range(5):
    print(i)
else:
    print("Bucle completado")
```

# ğŸ“”Manejo de errores con Try, Except y Finally

El manejo de errores en Python se realiza mediante las sentencias `try`, `except`, y `finally`. Estas estructuras permiten gestionar situaciones en las que el cÃ³digo puede generar errores, asegurando que el programa no se detenga inesperadamente y ofreciendo soluciones controladas a los problemas.

------

### ğŸ“–**Â¿QuÃ© es el manejo de errores?**

El manejo de errores consiste en anticipar posibles excepciones (errores) que puedan surgir durante la ejecuciÃ³n de un programa y definir cÃ³mo responder ante ellas. Esto mejora la robustez y estabilidad del cÃ³digo.

------

### ğŸ“–**La estructura bÃ¡sica**

#### **Sintaxis:**

```python
try:
    # CÃ³digo que puede generar un error
except ExcepcionEspecifica:
    # CÃ³digo que se ejecuta si ocurre la excepciÃ³n especificada
finally:
    # CÃ³digo que se ejecuta siempre, ocurra o no una excepciÃ³n (opcional)
```

------

### ğŸ“–**ExplicaciÃ³n de las clÃ¡usulas**

#### **ğŸ“ƒ`try`:**

Contiene el cÃ³digo que se ejecuta normalmente, pero que puede generar una excepciÃ³n.

#### **ğŸ“ƒ `except`:**

Se ejecuta solo si ocurre una excepciÃ³n en el bloque `try`. Puede manejar excepciones especÃ­ficas o generales.

**Ejemplo de manejo especÃ­fico:**

```python
try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("Error: No se puede dividir entre cero.")
```

**Ejemplo de manejo general:**

```python
try:
    resultado = int("texto")
except Exception as e:
    print(f"Error general: {e}")
```

#### **ğŸ“ƒ `finally`:**

Se ejecuta siempre, independientemente de si ocurre o no una excepciÃ³n. Ãštil para realizar acciones de limpieza como cerrar archivos o liberar recursos.

**Ejemplo:**

```python
try:
    archivo = open("datos.txt", "r")
    contenido = archivo.read()
except FileNotFoundError:
    print("El archivo no existe.")
finally:
    print("Finalizando proceso...")
    if 'archivo' in locals() and not archivo.closed:
        archivo.close()
```

------

### ğŸ“–**Capturar mÃºltiples excepciones**

Un bloque `try` puede manejar diferentes tipos de excepciones usando varios bloques `except`:

```python
try:
    numero = int(input("Introduce un nÃºmero: "))
    resultado = 10 / numero
except ValueError:
    print("Debes introducir un nÃºmero vÃ¡lido.")
except ZeroDivisionError:
    print("No se puede dividir entre cero.")
```

------

### ğŸ“–**Usar `else` en el manejo de errores**

La clÃ¡usula `else` se ejecuta si no se produce ninguna excepciÃ³n en el bloque `try`. Es Ãºtil para realizar acciones solo cuando no hubo errores.

**Ejemplo:**

```python
try:
    numero = int(input("Introduce un nÃºmero: "))
    resultado = 10 / numero
except (ValueError, ZeroDivisionError) as e:
    print(f"Error: {e}")
else:
    print("OperaciÃ³n exitosa. Resultado:", resultado)
finally:
    print("Fin del programa.")
```

### ğŸ“–Tipos de excepciones
| **Tipo de Error**        | **DescripciÃ³n**                                                                 | **Ejemplo**                                                                                     |
|---------------------------|---------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **`SyntaxError`**         | Se genera cuando hay un error en la sintaxis del cÃ³digo, lo que impide que sea interpretado. | ```python\nif True print("Hola")\n``` **Salida:** `SyntaxError: expected ':'`                 |
| **`IndentationError`**    | Se produce cuando hay un problema con la indentaciÃ³n, como faltas o exceso de espacios.       | ```python\ndef funcion():\nprint("Hola")\n``` **Salida:** `IndentationError: expected an indented block` |
| **`NameError`**           | Ocurre cuando se intenta usar una variable o funciÃ³n que no ha sido definida.               | ```python\nprint(x)\n``` **Salida:** `NameError: name 'x' is not defined`                     |
| **`TypeError`**           | Se lanza cuando se realiza una operaciÃ³n no permitida entre tipos incompatibles.            | ```python\nresultado = "texto" + 5\n``` **Salida:** `TypeError: can only concatenate str (not "int") to str` |
| **`ValueError`**          | Ocurre cuando se proporciona un valor inapropiado para una operaciÃ³n vÃ¡lida.                | ```python\nnumero = int("texto")\n``` **Salida:** `ValueError: invalid literal for int() with base 10: 'texto'` |
| **`ZeroDivisionError`**   | Se genera cuando se intenta dividir un nÃºmero entre cero, lo cual no estÃ¡ permitido.         | ```python\nresultado = 10 / 0\n``` **Salida:** `ZeroDivisionError: division by zero`          |
| **`IndexError`**          | Se lanza cuando se intenta acceder a un Ã­ndice que estÃ¡ fuera del rango de una lista o secuencia. | ```python\nlista = [1, 2, 3]\nprint(lista[5])\n``` **Salida:** `IndexError: list index out of range` |
| **`KeyError`**            | Se produce cuando se intenta acceder a una clave inexistente en un diccionario.             | ```python\ndiccionario = {"a": 1}\nprint(diccionario["b"])\n``` **Salida:** `KeyError: 'b'`   |
| **`AttributeError`**      | Ocurre cuando se intenta acceder a un atributo que no existe en un objeto.                  | ```python\ntexto = "Hola"\ntexto.append("!")\n``` **Salida:** `AttributeError: 'str' object has no attribute 'append'` |
| **`ModuleNotFoundError`** | Se genera cuando se intenta importar un mÃ³dulo que no estÃ¡ disponible o no existe.          | ```python\nimport modulo_inexistente\n``` **Salida:** `ModuleNotFoundError: No module named 'modulo_inexistente'` |
| **`ImportError`**         | Ocurre cuando un mÃ³dulo existe, pero hay problemas al importar algo especÃ­fico.             | ```python\nfrom math import raiz\n``` **Salida:** `ImportError: cannot import name 'raiz' from 'math'` |
| **`FileNotFoundError`**   | Se lanza cuando se intenta abrir un archivo que no existe en el sistema.                    | ```python\nwith open("archivo_inexistente.txt", "r") as archivo:\n    contenido = archivo.read()\n``` **Salida:** `FileNotFoundError: [Errno 2] No such file or directory: 'archivo_inexistente.txt'` |
| **`IOError`**             | Ocurre durante operaciones de entrada/salida que fallan, como leer o escribir un archivo.   | ```python\nwith open("/ruta_protegida/archivo.txt", "w") as archivo:\n    archivo.write("Texto")\n``` **Salida:** `IOError: [Errno 13] Permission denied: '/ruta_protegida/archivo.txt'` |
| **`OverflowError`**       | Se produce cuando un cÃ¡lculo numÃ©rico excede el lÃ­mite permitido.                          | ```python\nimport math\nresultado = math.exp(1000)\n``` **Salida:** `OverflowError: math range error` |
| **`RecursionError`**      | Se lanza cuando se excede el lÃ­mite de recursiÃ³n permitido en una funciÃ³n recursiva.        | ```python\ndef recursiva():\n    return recursiva()\nrecursiva()\n``` **Salida:** `RecursionError: maximum recursion depth exceeded` |
| **`MemoryError`**         | Se genera cuando el sistema no tiene suficiente memoria para completar una operaciÃ³n.       | ```python\nlista = [1] * (10**10)\n``` **Salida:** `MemoryError`                              |
| **`RuntimeError`**        | Error genÃ©rico que ocurre en tiempo de ejecuciÃ³n por condiciones inesperadas.               | ```python\nraise RuntimeError("Error inesperado")\n``` **Salida:** `RuntimeError: Error inesperado` |

# ğŸ“”Cadena de Caracteres

## ğŸ“–**MÃ©todos para ManipulaciÃ³n BÃ¡sica**

Python proporciona varios mÃ©todos integrados para manipular cadenas de caracteres. Estos permiten modificar, buscar, reemplazar o dividir cadenas fÃ¡cilmente.

### ğŸ“ƒ**Principales mÃ©todos:**

| **MÃ©todo**              | **DescripciÃ³n**                                              | **Ejemplo**                             | **Resultado**       |
| ----------------------- | ------------------------------------------------------------ | --------------------------------------- | ------------------- |
| `len(cadena)`           | Devuelve la longitud de la cadena.                           | `len("Hola")`                           | `4`                 |
| `cadena.lower()`        | Convierte todos los caracteres de la cadena a minÃºsculas.    | `"Hola".lower()`                        | `"hola"`            |
| `cadena.upper()`        | Convierte todos los caracteres de la cadena a mayÃºsculas.    | `"Hola".upper()`                        | `"HOLA"`            |
| `cadena.strip()`        | Elimina espacios en blanco al inicio y al final de la cadena. | `" Hola ".strip()`                      | `"Hola"`            |
| `cadena.replace(a, b)`  | Reemplaza todas las ocurrencias de `a` por `b` en la cadena. | `"Hola Mundo".replace("Hola", "AdiÃ³s")` | `"AdiÃ³s Mundo"`     |
| `cadena.split(sep)`     | Divide la cadena en una lista de palabras utilizando el separador `sep`. | `"Hola Mundo".split(" ")`               | `["Hola", "Mundo"]` |
| `cadena.join(iterable)` | Une los elementos de un iterable en una sola cadena usando `cadena` como separador. | `" ".join(["Hola", "Mundo"])`           | `"Hola Mundo"`      |

------

## ğŸ“–**MÃ©todos para ValidaciÃ³n**

Estos mÃ©todos se utilizan para verificar si una cadena cumple con ciertas condiciones. Devuelven un valor booleano (`True` o `False`).

### ğŸ“ƒ**Principales mÃ©todos:**

| **MÃ©todo**                   | **DescripciÃ³n**                                              | **Ejemplo**                       | **Resultado** |
| ---------------------------- | ------------------------------------------------------------ | --------------------------------- | ------------- |
| `cadena.isalpha()`           | Retorna `True` si todos los caracteres son alfabÃ©ticos.      | `"Hola".isalpha()`                | `True`        |
| `cadena.isdigit()`           | Retorna `True` si todos los caracteres son dÃ­gitos.          | `"1234".isdigit()`                | `True`        |
| `cadena.isalnum()`           | Retorna `True` si todos los caracteres son alfanumÃ©ricos (letras o nÃºmeros). | `"Hola123".isalnum()`             | `True`        |
| `cadena.isspace()`           | Retorna `True` si todos los caracteres son espacios en blanco. | `" ".isspace()`                   | `True`        |
| `cadena.startswith(prefijo)` | Retorna `True` si la cadena comienza con el prefijo especificado. | `"Hola Mundo".startswith("Hola")` | `True`        |
| `cadena.endswith(sufijo)`    | Retorna `True` si la cadena termina con el sufijo especificado. | `"Hola Mundo".endswith("Mundo")`  | `True`        |

------

## ğŸ“–**MÃ©todos de Formateo**

Estos mÃ©todos permiten ajustar o modificar el formato de una cadena.

### ğŸ“ƒ**Principales mÃ©todos:**

| **MÃ©todo**                       | **DescripciÃ³n**                                              | **Ejemplo**                          | **Resultado**   |
| -------------------------------- | ------------------------------------------------------------ | ------------------------------------ | --------------- |
| `cadena.center(ancho)`           | Centra la cadena dentro de un espacio de ancho especificado. | `"Hola".center(10)`                  | `" Hola "`      |
| `cadena.ljust(ancho)`            | Justifica la cadena a la izquierda con un ancho especificado. | `"Hola".ljust(10)`                   | `"Hola "`       |
| `cadena.rjust(ancho)`            | Justifica la cadena a la derecha con un ancho especificado.  | `"Hola".rjust(10)`                   | `" Hola"`       |
| `cadena.zfill(ancho)`            | Rellena la cadena con ceros a la izquierda hasta alcanzar el ancho especificado. | `"123".zfill(5)`                     | `"00123"`       |
| `cadena.format(*args, **kwargs)` | Reemplaza marcadores de posiciÃ³n `{}` en la cadena con los valores proporcionados. | `"Hola, {}".format("Mundo")`         | `"Hola, Mundo"` |
| `f"CÃ³digo {variable}"`           | Cadenas formateadas (`f-strings`), permite insertar variables en la cadena. | `nombre = "Juan"; f"Hola, {nombre}"` | `"Hola, Juan"`  |

## â‡**Taller Guiado: Trabajando con Cadenas de Caracteres en Python**

Este taller estÃ¡ diseÃ±ado para practicar el uso de cadenas de caracteres en Python. Cada ejercicio tiene instrucciones claras y una explicaciÃ³n de cÃ³mo resolverlo.

------

### **Objetivo del taller**

- Aprender a manipular, validar y formatear cadenas de caracteres.
- Usar los mÃ©todos bÃ¡sicos de las cadenas para resolver problemas prÃ¡cticos.

------

### **Ejercicio 1: Contando caracteres**

#### **InstrucciÃ³n:**

Escribe un programa que solicite al usuario una frase y muestre:

1. La cantidad total de caracteres en la frase.
2. La cantidad de espacios en la frase.

#### **GuÃ­a:**

1. Usa `len()` para contar el total de caracteres.
2. Usa el mÃ©todo `count()` para contar los espacios.

#### **CÃ³digo base:**

```python
frase = input("Escribe una frase: ")
total_caracteres = len(frase)
espacios = frase.count(" ")

print(f"La frase tiene {total_caracteres} caracteres en total.")
print(f"La frase tiene {espacios} espacios.")
```

------

### **Ejercicio 2: Validando nombres**

#### **InstrucciÃ³n:**

Crea un programa que solicite al usuario su nombre completo y verifique:

1. Que solo contenga letras.
2. Que comience con mayÃºscula.

#### **GuÃ­a:**

1. Usa `isalpha()` para verificar que solo hay letras.
2. Usa `istitle()` para verificar que las palabras comiencen con mayÃºscula.

#### **CÃ³digo base:**

```python
nombre = input("Escribe tu nombre completo: ")

if nombre.replace(" ", "").isalpha():
    if nombre.istitle():
        print("El nombre es vÃ¡lido.")
    else:
        print("El nombre debe comenzar con mayÃºscula.")
else:
    print("El nombre solo debe contener letras.")
```

------

### **Ejercicio 3: Invirtiendo palabras**

#### **InstrucciÃ³n:**

Escribe un programa que pida al usuario una palabra y muestre la palabra invertida.

#### **GuÃ­a:**

1. Usa el operador de slicing `[::-1]` para invertir la cadena.

#### **CÃ³digo base:**

```python
palabra = input("Escribe una palabra: ")
invertida = palabra[::-1]
print(f"La palabra invertida es: {invertida}")
```

------

### **Ejercicio 4: Cifrando texto**

#### **InstrucciÃ³n:**

Crea un programa que solicite al usuario una frase y reemplace todas las vocales por un carÃ¡cter especial (*).

#### **GuÃ­a:**

1. Usa `replace()` repetidamente para reemplazar las vocales.
2. AsegÃºrate de manejar tanto mayÃºsculas como minÃºsculas.

#### **CÃ³digo base:**

```python
frase = input("Escribe una frase: ")

frase_cifrada = frase.replace("a", "*").replace("e", "*").replace("i", "*").replace("o", "*").replace("u", "*")
frase_cifrada = frase_cifrada.replace("A", "*").replace("E", "*").replace("I", "*").replace("O", "*").replace("U", "*")

print(f"La frase cifrada es: {frase_cifrada}")
```

------

### **Ejercicio 5: Contador de vocales**

#### **InstrucciÃ³n:**

Escribe un programa que cuente cuÃ¡ntas vocales hay en una frase ingresada por el usuario.

#### **GuÃ­a:**

1. Usa `count()` para contar las vocales individualmente.
2. Suma los resultados.

#### **CÃ³digo base:**

```python
frase = input("Escribe una frase: ")

a = frase.count("a") + frase.count("A")
e = frase.count("e") + frase.count("E")
i = frase.count("i") + frase.count("I")
o = frase.count("o") + frase.count("O")
u = frase.count("u") + frase.count("U")

total_vocales = a + e + i + o + u

print(f"La frase tiene {total_vocales} vocales.")
```

------

### **Ejercicio 6: Formateando cadenas**

#### **InstrucciÃ³n:**

Escribe un programa que tome un nÃºmero de telÃ©fono ingresado por el usuario (10 dÃ­gitos) y lo formatee como `(XXX) XXX-XXXX`.

#### **GuÃ­a:**

1. Usa slicing para dividir la cadena en partes.
2. Usa `f-strings` o concatenaciÃ³n para formatear.

#### **CÃ³digo base:**

```python
telefono = input("Escribe un nÃºmero de telÃ©fono de 10 dÃ­gitos: ")
if len(telefono) == 10 and telefono.isdigit():
    telefono_formateado = f"({telefono[:3]}) {telefono[3:6]}-{telefono[6:]}"
    print(f"El nÃºmero formateado es: {telefono_formateado}")
else:
    print("El nÃºmero debe tener exactamente 10 dÃ­gitos.")
```

------

### **Ejercicio 7: Detectando palÃ­ndromos**

#### **InstrucciÃ³n:**

Escribe un programa que determine si una palabra ingresada por el usuario es un palÃ­ndromo (se lee igual al derecho y al revÃ©s).

#### **GuÃ­a:**

1. Usa slicing para invertir la palabra.
2. Compara la palabra original con la invertida.

#### **CÃ³digo base:**

```python
palabra = input("Escribe una palabra: ").lower()
invertida = palabra[::-1]

if palabra == invertida:
    print("La palabra es un palÃ­ndromo.")
else:
    print("La palabra no es un palÃ­ndromo.")
```

# ğŸ“”Estructuras de datos

## ğŸ“–Listas

Las listas en Python son estructuras de datos **ordenadas**, **mutables** y que pueden contener elementos de cualquier tipo (nÃºmeros, cadenas, otros objetos, incluso otras listas). Son muy flexibles y se utilizan para almacenar colecciones de elementos.

#### ğŸ“ƒ**CaracterÃ­sticas clave:**

- Las listas estÃ¡n delimitadas por corchetes (`[]`).
- Los elementos estÃ¡n separados por comas.
- Pueden contener datos heterogÃ©neos.

**Ejemplo bÃ¡sico:**

```python
pythonCopiarEditarmi_lista = [1, "Python", True, 3.14]
print(mi_lista)  # Salida: [1, 'Python', True, 3.14]
```

------

#### ğŸ“ƒ**CreaciÃ³n de listas**

Existen varias formas de crear listas en Python.

##### **ğŸ”–Listas literales:**

Se crean directamente utilizando corchetes (`[]`).

```python
mi_lista = [1, 2, 3]
```

##### **ğŸ”– Listas vacÃ­as:**

```python
lista_vacia = []
```

##### **ğŸ”–Usando el constructor `list()`:**

```python
mi_lista = list((1, 2, 3))  # Se pasa una tupla como argumento
```

##### **ğŸ”–Con comprensiÃ³n de listas:**

Una forma concisa de crear listas usando bucles.

```python
cuadrados = [x**2 for x in range(5)]  # Salida: [0, 1, 4, 9, 16]
```

------

### ğŸ“ƒ**ManipulaciÃ³n de listas**

Python proporciona muchos mÃ©todos y operadores para manipular listas.

#### **ğŸ”–`append(x)`**

AÃ±ade un elemento al final de la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.append(4)
print(mi_lista)  # Salida: [1, 2, 3, 4]
```

------

#### ğŸ”–

Extiende la lista aÃ±adiendo todos los elementos de un iterable (como otra lista, una tupla o un string).

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.extend([4, 5, 6])
print(mi_lista)  # Salida: [1, 2, 3, 4, 5, 6]
```

------

#### **ğŸ”–`insert(i, x)`**

Inserta un elemento en una posiciÃ³n especÃ­fica. `i` es el Ã­ndice donde se insertarÃ¡ el elemento.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.insert(1, "Python")
print(mi_lista)  # Salida: [1, 'Python', 2, 3]
```

------

#### **ğŸ”– `remove(x)`**

Elimina la primera apariciÃ³n del valor `x` en la lista. Lanza un error si el valor no estÃ¡ presente.

**Ejemplo:**

```
mi_lista = [1, 2, 3, 2]
mi_lista.remove(2)
print(mi_lista)  # Salida: [1, 3, 2]
```

------

#### **ğŸ”– `pop([i])`**

Elimina y devuelve el elemento en la posiciÃ³n `i`. Si no se especifica `i`, elimina y devuelve el Ãºltimo elemento.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
ultimo = mi_lista.pop()
print(ultimo)  # Salida: 3
print(mi_lista)  # Salida: [1, 2]
```

------

#### **ğŸ”–`clear()`**

Elimina todos los elementos de la lista, dejÃ¡ndola vacÃ­a.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.clear()
print(mi_lista)  # Salida: []
```

------

#### **ğŸ”– `index(x[, start[, end]])`**

Devuelve el Ã­ndice de la primera apariciÃ³n de `x` en la lista. Opcionalmente, se puede buscar dentro de un rango con `start` y `end`.

**Ejemplo:**

```
mi_lista = [10, 20, 30, 20]
indice = mi_lista.index(20)
print(indice)  # Salida: 1
```

**Con rango:**

```
indice = mi_lista.index(20, 2)
print(indice)  # Salida: 3
```

------

#### **ğŸ”–`count(x)`**

Devuelve el nÃºmero de veces que `x` aparece en la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 2, 3, 2]
cantidad = mi_lista.count(2)
print(cantidad)  # Salida: 3
```

------

#### **ğŸ”–`sort(key=None, reverse=False)`**

Ordena los elementos de la lista de menor a mayor (por defecto). Se puede personalizar el orden con los parÃ¡metros:

- **`key`:** Una funciÃ³n que define el criterio de orden.
- **`reverse`:** Si es `True`, ordena de mayor a menor.

**Ejemplo bÃ¡sico:**

```
mi_lista = [3, 1, 4, 2]
mi_lista.sort()
print(mi_lista)  # Salida: [1, 2, 3, 4]
```

**Orden descendente:**

```
mi_lista.sort(reverse=True)
print(mi_lista)  # Salida: [4, 3, 2, 1]
```

**Con clave personalizada:**

```
mi_lista = ["hola", "Python", "mundo"]
mi_lista.sort(key=len)
print(mi_lista)  # Salida: ['hola', 'mundo', 'Python']
```

------

#### **ğŸ”–`reverse()`**

Invierte el orden de los elementos en la lista.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
mi_lista.reverse()
print(mi_lista)  # Salida: [3, 2, 1]
```

------

#### **ğŸ”– `copy()`**

Devuelve una copia superficial de la lista. Los cambios en la copia no afectan a la lista original.

**Ejemplo:**

```
mi_lista = [1, 2, 3]
copia = mi_lista.copy()
copia.append(4)
print(mi_lista)  # Salida: [1, 2, 3]
print(copia)     # Salida: [1, 2, 3, 4]
```

------

#### ğŸ“’**Resumen de MÃ©todos de Listas**

| **MÃ©todo**         | **DescripciÃ³n**                                              |
| ------------------ | ------------------------------------------------------------ |
| `append(x)`        | AÃ±ade un elemento al final de la lista.                      |
| `extend(iterable)` | AÃ±ade todos los elementos de un iterable a la lista.         |
| `insert(i, x)`     | Inserta un elemento en la posiciÃ³n especificada.             |
| `remove(x)`        | Elimina la primera apariciÃ³n del valor dado.                 |
| `pop([i])`         | Elimina y devuelve el elemento en la posiciÃ³n especificada (o el Ãºltimo). |
| `clear()`          | Elimina todos los elementos de la lista.                     |
| `index(x[, s, e])` | Devuelve el Ã­ndice de la primera apariciÃ³n de un valor.      |
| `count(x)`         | Cuenta cuÃ¡ntas veces aparece un valor en la lista.           |
| `sort()`           | Ordena los elementos de la lista.                            |
| `reverse()`        | Invierte el orden de los elementos de la lista.              |
| `copy()`           | Devuelve una copia de la lista.                              |

## ğŸ“–**Lista de listas**

Las listas pueden contener otras listas, lo que permite crear estructuras anidadas (matrices, tablas, etc.).

#### ğŸ“ƒ**Acceso a listas anidadas:**

```python
matriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matriz[0])       # Salida: [1, 2, 3]
print(matriz[0][1])    # Salida: 2
```

#### **ğŸ“ƒManipulaciÃ³n de listas anidadas:**

```python
matriz[1].append(10)
print(matriz)  # Salida: [[1, 2, 3], [4, 5, 6, 10], [7, 8, 9]]
```

------

#### **Resumen**

Las listas en Python son una estructura de datos fundamental que permite almacenar y manipular colecciones de elementos de forma flexible. Aprender a usarlas de manera eficiente, incluyendo su creaciÃ³n, manipulaciÃ³n y uso en estructuras mÃ¡s complejas como listas anidadas, es clave para desarrollar programas robustos.

## ğŸ“”Diccionarios

### ğŸ“–**Conceptos bÃ¡sicos**

Un diccionario en Python es una colecciÃ³n de pares clave-valor, donde:

- Cada clave es Ãºnica e inmutable (puede ser un nÃºmero, cadena o tupla).
- Cada valor estÃ¡ asociado con una clave y puede ser de cualquier tipo.

### ğŸ“–**CaracterÃ­sticas principales:**

- Los diccionarios son mutables (pueden modificarse despuÃ©s de ser creados).
- No admiten claves duplicadas, pero los valores sÃ­ pueden repetirse.

#### **Ejemplo bÃ¡sico:**

```python
mi_diccionario = {
    "nombre": "Juan",
    "edad": 30,
    "ciudad": "BogotÃ¡"
}
print(mi_diccionario)  # Salida: {'nombre': 'Juan', 'edad': 30, 'ciudad': 'BogotÃ¡'}
```

### ğŸ“–**CreaciÃ³n de diccionarios**

Python ofrece varias formas de crear diccionarios.

#### **a) Usando llaves (`{}`):**

```python
diccionario = {"clave1": "valor1", "clave2": "valor2"}
```

#### **b) Usando el constructor `dict()`:**

```python
diccionario = dict(clave1="valor1", clave2="valor2")
```

#### **c) Diccionario vacÃ­o:**

```python
diccionario = {}
```

#### **d) Usando `zip()`:**

Asocia elementos de dos listas para formar pares clave-valor.

```python
claves = ["nombre", "edad", "ciudad"]
valores = ["Ana", 25, "MedellÃ­n"]
diccionario = dict(zip(claves, valores))
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'MedellÃ­n'}
```

### ğŸ“–Metodos

#### **1. `dict.get(clave, valor_por_defecto=None)`**

Obtiene el valor asociado a una clave. Si la clave no existe, devuelve un valor por defecto (por defecto es `None`).

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.get("nombre"))  # Salida: Ana
print(diccionario.get("ciudad", "No especificado"))  # Salida: No especificado
```

------

#### **2. `dict.keys()`**

Devuelve una vista de todas las claves del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.keys())  # Salida: dict_keys(['nombre', 'edad'])
```

------

#### **3. `dict.values()`**

Devuelve una vista de todos los valores del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.values())  # Salida: dict_values(['Ana', 25])
```

------

#### **4. `dict.items()`**

Devuelve una vista de todos los pares clave-valor como tuplas.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
print(diccionario.items())  # Salida: dict_items([('nombre', 'Ana'), ('edad', 25)])
```

------

#### **5. `dict.update(otro_diccionario)`**

Actualiza el diccionario con los pares clave-valor de otro diccionario o iterable.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana"}
nuevo_datos = {"edad": 25, "ciudad": "BogotÃ¡"}
diccionario.update(nuevo_datos)
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'BogotÃ¡'}
```

------

#### **6. `dict.pop(clave, valor_por_defecto)`**

Elimina la clave especificada y devuelve su valor. Si la clave no existe, devuelve el valor por defecto.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
edad = diccionario.pop("edad")
print(edad)  # Salida: 25
print(diccionario)  # Salida: {'nombre': 'Ana'}
```

------

#### **7. `dict.popitem()`**

Elimina y devuelve un par clave-valor aleatorio (en Python 3.7+ elimina el Ãºltimo).

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
par = diccionario.popitem()
print(par)  # Salida: ('edad', 25)
print(diccionario)  # Salida: {'nombre': 'Ana'}
```

------

#### **8. `dict.clear()`**

Elimina todos los elementos del diccionario, dejÃ¡ndolo vacÃ­o.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
diccionario.clear()
print(diccionario)  # Salida: {}
```

------

#### **9. `dict.copy()`**

Devuelve una copia superficial del diccionario.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana", "edad": 25}
copia = diccionario.copy()
copia["ciudad"] = "BogotÃ¡"
print(diccionario)  # Salida: {'nombre': 'Ana', 'edad': 25}
print(copia)  # Salida: {'nombre': 'Ana', 'edad': 25, 'ciudad': 'BogotÃ¡'}
```

------

#### **10. `dict.setdefault(clave, valor_por_defecto)`**

Devuelve el valor de la clave si existe. Si no, agrega la clave con el valor por defecto y devuelve ese valor.

**Ejemplo:**

```python
diccionario = {"nombre": "Ana"}
valor = diccionario.setdefault("ciudad", "BogotÃ¡")
print(valor)  # Salida: BogotÃ¡
print(diccionario)  # Salida: {'nombre': 'Ana', 'ciudad': 'BogotÃ¡'}
```

------

#### **11. `dict.fromkeys(iterable, valor_por_defecto=None)`**

Crea un diccionario con las claves del iterable y un valor por defecto para cada clave.

**Ejemplo:**

```python
claves = ["nombre", "edad", "ciudad"]
diccionario = dict.fromkeys(claves, "Desconocido")
print(diccionario)  # Salida: {'nombre': 'Desconocido', 'edad': 'Desconocido', 'ciudad': 'Desconocido'}
```

------

#### **12. Comparando diccionarios**

Se pueden usar operadores de comparaciÃ³n para verificar igualdad.

**Ejemplo:**

```python
diccionario1 = {"nombre": "Ana", "edad": 25}
diccionario2 = {"edad": 25, "nombre": "Ana"}
print(diccionario1 == diccionario2)  # Salida: True
```

------

#### **Resumen de MÃ©todos**

| **MÃ©todo**                      | **DescripciÃ³n**                                              |
| ------------------------------- | ------------------------------------------------------------ |
| `get(clave, valor_por_defecto)` | Devuelve el valor de una clave o un valor por defecto.       |
| `keys()`                        | Devuelve todas las claves del diccionario.                   |
| `values()`                      | Devuelve todos los valores del diccionario.                  |
| `items()`                       | Devuelve todos los pares clave-valor como tuplas.            |
| `update()`                      | Actualiza el diccionario con pares clave-valor de otro.      |
| `pop(clave, valor_por_defecto)` | Elimina y devuelve el valor asociado a una clave.            |
| `popitem()`                     | Elimina y devuelve un par clave-valor aleatorio.             |
| `clear()`                       | Elimina todos los elementos del diccionario.                 |
| `copy()`                        | Devuelve una copia superficial del diccionario.              |
| `setdefault(clave, valor)`      | Devuelve el valor de una clave, si no existe la agrega con el valor dado. |
| `fromkeys(iterable, valor)`     | Crea un diccionario con las claves del iterable y un valor comÃºn. |

# ğŸ“”Persistencia

### ğŸ“–**Persistencia en ProgramaciÃ³n**

La **persistencia en programaciÃ³n** se refiere a la capacidad de un sistema o aplicaciÃ³n para **almacenar y recuperar datos de manera duradera**, incluso despuÃ©s de que el programa haya terminado su ejecuciÃ³n. Es un concepto fundamental en el desarrollo de software, especialmente en aplicaciones que requieren conservar informaciÃ³n a lo largo del tiempo.

------

### ğŸ“–**Tipos de Persistencia**

1. **Persistencia en Memoria (VolÃ¡til)**

   - Los datos se almacenan en la RAM mientras el programa estÃ¡ en ejecuciÃ³n.
   - Ejemplo: Variables, arreglos, estructuras de datos temporales.
   - **Desventaja:** Los datos se pierden cuando el programa se cierra.

2. **Persistencia en Archivos (No VolÃ¡til)**

   - Guarda los datos en archivos en el sistema de almacenamiento.

   - Formatos comunes: `.txt`, `.csv`, `.json`, `.xml`, `.log`.

   - Ejemplo en Python:

     ```
     rwith open("datos.txt", "w") as archivo:
         archivo.write("Hola, esto es un archivo de texto")
     ```

3. **Persistencia en Bases de Datos**

   - Usa sistemas de bases de datos para almacenar grandes volÃºmenes de informaciÃ³n.

   - Puede ser **relacional** (SQL) o **NoSQL** (MongoDB, Firebase).

   - Ejemplo en SQL (MySQL):

     ```
     CREATE TABLE usuarios (
         id INT PRIMARY KEY AUTO_INCREMENT,
         nombre VARCHAR(50),
         email VARCHAR(100)
     );
     ```

4. **Persistencia en la Nube**

   - Almacenamiento de datos en servidores remotos accesibles por Internet.
   - Ejemplos: Google Firebase, AWS S3, Microsoft Azure.

5. **Persistencia en CachÃ©**

   - Se almacenan datos temporalmente en memoria para mejorar el rendimiento.
   - Ejemplo: Redis, Memcached.

------

### ğŸ“–**Mecanismos de Persistencia**

âœ… **Bases de Datos Relacionales (SQL)**

- MySQL, PostgreSQL, Oracle, SQL Server.
- Usa **tablas y relaciones** para organizar los datos.

âœ… **Bases de Datos NoSQL**

- MongoDB, Firebase, CouchDB.
- Almacenan datos en formato **JSON o BSON**, sin estructuras fijas.

âœ… **Archivos Locales**

- Archivos JSON, XML, CSV, binarios.

âœ… **ORM (Object-Relational Mapping)**

- Herramientas como Hibernate (Java), SQLAlchemy (Python), TypeORM (JavaScript) permiten interactuar con bases de datos mediante objetos en lugar de SQL puro.

âœ… **Almacenamiento en la Nube**

- Firebase, AWS S3, Google Cloud Storage.

âœ… **Session Storage & Local Storage (Web)**

- Para persistencia en navegadores sin necesidad de base de datos.

- Ejemplo en JavaScript:

  ```
  localStorage.setItem("usuario", "Johlver");
  console.log(localStorage.getItem("usuario")); // "Johlver"
  ```

------

### ğŸ“–**Ejemplo de Persistencia con JSON en JavaScript**

```
// Crear objeto
const usuario = { nombre: "Johlver", edad: 25 };

// Convertir a JSON y guardar en localStorage
localStorage.setItem("usuario", JSON.stringify(usuario));

// Recuperar datos
const datosRecuperados = JSON.parse(localStorage.getItem("usuario"));
console.log(datosRecuperados); // { nombre: "Johlver", edad: 25 }
```

------

### ğŸ“–**Importancia de la Persistencia**

- Permite que los datos **se mantengan despuÃ©s de cerrar el programa**.
- Es clave en aplicaciones web, mÃ³viles y sistemas empresariales.
- Mejora la escalabilidad y accesibilidad de la informaciÃ³n.
- Facilita la **integraciÃ³n con otras aplicaciones** y servicios.

### ğŸ“”Archivos en python

En Python, el manejo de archivos se realiza con la funciÃ³n `open()`, que permite leer, escribir, modificar y cerrar archivos. A continuaciÃ³n, te explicarÃ© los **mÃ©todos** y **parÃ¡metros** mÃ¡s usados en la manipulaciÃ³n de archivos.

#### **ğŸ“Œ `open()` - Apertura de Archivos**

La funciÃ³n `open()` se usa para abrir un archivo y devuelve un objeto de tipo archivo.

#### **ğŸ”¹ Sintaxis:**

```
archivo = open("nombre_del_archivo", "modo", encoding="utf-8")
```

- `"nombre_del_archivo"`: Nombre del archivo con su ruta (ejemplo: `"datos.txt"`).
- `"modo"`: Indica la acciÃ³n que se realizarÃ¡ sobre el archivo.
- `encoding="utf-8"`: (Opcional) Especifica la codificaciÃ³n del archivo, recomendada para caracteres especiales.

------

#### **ğŸ“œ Modos de Apertura de Archivos**

Los modos de apertura determinan quÃ© operaciÃ³n se realizarÃ¡ sobre el archivo:

| Modo   | AcciÃ³n                                                       |
| ------ | ------------------------------------------------------------ |
| `"r"`  | Modo **lectura** (por defecto). Da error si el archivo no existe. |
| `"w"`  | Modo **escritura**, sobrescribe el archivo si ya existe. Si no existe, lo crea. |
| `"a"`  | Modo **agregar** (append). Agrega texto al final sin sobrescribir el contenido existente. |
| `"x"`  | Modo **creaciÃ³n exclusiva**. Da error si el archivo ya existe. |
| `"r+"` | **Lectura y escritura**, sin borrar el contenido.            |
| `"w+"` | **Lectura y escritura**, pero sobrescribe el contenido.      |
| `"a+"` | **Lectura y escritura**, pero agrega datos al final.         |
| `"b"`  | Se usa junto con otros modos (`rb`, `wb`, `ab`) para archivos binarios. |

------

#### **ğŸ“Œ MÃ©todos para el Manejo de Archivos**

Una vez que se abre un archivo, se pueden usar los siguientes mÃ©todos:

#### **ğŸ“– Lectura de Archivos**

##### ğŸ”¹ `read()` - Lee todo el contenido del archivo

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    contenido = archivo.read()
    print(contenido)
```

ğŸ“Œ **Nota:** Si el archivo es muy grande, `read()` puede consumir mucha memoria.

##### ğŸ”¹ `readline()` - Lee una sola lÃ­nea

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    primera_linea = archivo.readline()
    print(primera_linea)
```

ğŸ“Œ **Nota:** Cada llamada a `readline()` lee la siguiente lÃ­nea.

##### ğŸ”¹ `readlines()` - Lee todas las lÃ­neas y las almacena en una lista

```python
with open("archivo.txt", "r", encoding="utf-8") as archivo:
    lineas = archivo.readlines()
    print(lineas)  # ['Primera lÃ­nea\n', 'Segunda lÃ­nea\n']
```

ğŸ“Œ **Nota:** Cada lÃ­nea incluye el salto de lÃ­nea `\n`.

------

#### **âœï¸ Escritura en Archivos**

##### ğŸ”¹ `write()` - Escribe una cadena en el archivo

```python
with open("archivo.txt", "w", encoding="utf-8") as archivo:
    archivo.write("Hola, este es un archivo de prueba.\n")
```

ğŸ“Œ **Nota:** Si el archivo existe, se sobrescribe.

##### ğŸ”¹ `writelines()` - Escribe una lista de lÃ­neas en el archivo

```python
lineas = ["LÃ­nea 1\n", "LÃ­nea 2\n", "LÃ­nea 3\n"]

with open("archivo.txt", "w", encoding="utf-8") as archivo:
    archivo.writelines(lineas)
```

ğŸ“Œ **Nota:** `writelines()` **no** aÃ±ade automÃ¡ticamente `\n`, hay que incluirlo en cada lÃ­nea.

------

#### **ğŸ“ Agregar Texto sin Sobrescribir**

Si quieres **aÃ±adir contenido al final** del archivo sin eliminar lo que ya existe, usa el modo `"a"`:

```python
with open("archivo.txt", "a", encoding="utf-8") as archivo:
    archivo.write("Esta lÃ­nea se agrega al final.\n")
```

------

#### **ğŸš€ Lectura y Escritura al Mismo Tiempo**

Si deseas **leer y escribir** en el mismo archivo, usa `"r+"`, `"w+"` o `"a+"`:

```python
with open("archivo.txt", "r+", encoding="utf-8") as archivo:
    contenido = archivo.read()  # Leer contenido existente
    archivo.write("\nNueva lÃ­nea agregada.")  # Escribir sin borrar
```

------

#### **ğŸ“Œ Cerrar un Archivo con `close()`**

Es importante cerrar los archivos despuÃ©s de usarlos para evitar pÃ©rdida de datos.

```python
archivo = open("archivo.txt", "r", encoding="utf-8")
contenido = archivo.read()
archivo.close()
```

âœ… **RecomendaciÃ³n:** Usa `with open()` en lugar de `close()`, ya que Python cierra el archivo automÃ¡ticamente.

------

#### **ğŸ“‚ Ejemplo Completo: GestiÃ³n de Notas en un Archivo**

```python
def agregar_nota(nota):
    with open("notas.txt", "a", encoding="utf-8") as archivo:
        archivo.write(nota + "\n")

def mostrar_notas():
    with open("notas.txt", "r", encoding="utf-8") as archivo:
        print("ğŸ“„ Notas Guardadas:")
        print(archivo.read())

# Agregar notas
agregar_nota("Estudiar Python")
agregar_nota("Practicar archivos en Python")

# Mostrar notas almacenadas
mostrar_notas()
```

------

#### **ğŸ”¹ Resumen**

| MÃ©todo         | DescripciÃ³n                                            |
| -------------- | ------------------------------------------------------ |
| `open()`       | Abre un archivo para lectura, escritura o ambos.       |
| `read()`       | Lee todo el contenido del archivo.                     |
| `readline()`   | Lee una lÃ­nea del archivo.                             |
| `readlines()`  | Lee todas las lÃ­neas y las guarda en una lista.        |
| `write()`      | Escribe una cadena en el archivo (sobreescribe).       |
| `writelines()` | Escribe una lista de lÃ­neas en el archivo.             |
| `close()`      | Cierra el archivo (no es necesario con `with open()`). |

### ğŸ“”Persistencia con Archivos de texto

**Ejemplo prÃ¡ctico** que utiliza el manejo de archivos de texto en Python. Implementaremos un **gestor de tareas**, donde el usuario podrÃ¡:

âœ… Agregar tareas
âœ… Listar tareas
âœ… Marcar tareas como completadas
âœ… Eliminar tareas
âœ… Guardar todas las tareas en un archivo de texto (`tareas.txt`)**

#### **ğŸ“œ CÃ³digo del Gestor de Tareas**

```python
import os

ARCHIVO_TAREAS = "tareas.txt"

# FunciÃ³n para inicializar el archivo de tareas
def inicializar_archivo():
    if not os.path.exists(ARCHIVO_TAREAS):
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.write("")

# FunciÃ³n para agregar una tarea
def agregar_tarea(tarea):
    with open(ARCHIVO_TAREAS, "a", encoding="utf-8") as archivo:
        archivo.write(f"{tarea} | Pendiente\n")
    print(f"âœ… Tarea agregada: {tarea}")

# FunciÃ³n para listar todas las tareas
def listar_tareas():
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()
    
    if not tareas:
        print("ğŸ“‚ No hay tareas registradas.")
    else:
        print("\nğŸ“‹ Lista de Tareas:")
        for i, tarea in enumerate(tareas, start=1):
            print(f"{i}. {tarea.strip()}")

# FunciÃ³n para marcar una tarea como completada
def completar_tarea(numero):
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()

    if 1 <= numero <= len(tareas):
        tareas[numero - 1] = tareas[numero - 1].replace("Pendiente", "Completada")
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.writelines(tareas)
        print(f"âœ… Tarea {numero} marcada como completada.")
    else:
        print("âŒ NÃºmero de tarea invÃ¡lido.")

# FunciÃ³n para eliminar una tarea
def eliminar_tarea(numero):
    with open(ARCHIVO_TAREAS, "r", encoding="utf-8") as archivo:
        tareas = archivo.readlines()

    if 1 <= numero <= len(tareas):
        tarea_eliminada = tareas.pop(numero - 1)
        with open(ARCHIVO_TAREAS, "w", encoding="utf-8") as archivo:
            archivo.writelines(tareas)
        print(f"ğŸ—‘ï¸ Tarea eliminada: {tarea_eliminada.strip()}")
    else:
        print("âŒ NÃºmero de tarea invÃ¡lido.")

# FunciÃ³n principal con menÃº interactivo
def menu():
    inicializar_archivo()
    while True:
        print("\nğŸ“Œ MenÃº de Gestor de Tareas")
        print("1ï¸âƒ£ Agregar tarea")
        print("2ï¸âƒ£ Listar tareas")
        print("3ï¸âƒ£ Marcar tarea como completada")
        print("4ï¸âƒ£ Eliminar tarea")
        print("5ï¸âƒ£ Salir")
        opcion = input("Selecciona una opciÃ³n: ")

        if opcion == "1":
            tarea = input("DescripciÃ³n de la tarea: ")
            agregar_tarea(tarea)
        elif opcion == "2":
            listar_tareas()
        elif opcion == "3":
            listar_tareas()
            num = int(input("NÃºmero de la tarea a completar: "))
            completar_tarea(num)
        elif opcion == "4":
            listar_tareas()
            num = int(input("NÃºmero de la tarea a eliminar: "))
            eliminar_tarea(num)
        elif opcion == "5":
            print("ğŸ‘‹ Saliendo del gestor de tareas...")
            break
        else:
            print("âŒ OpciÃ³n invÃ¡lida. IntÃ©ntalo de nuevo.")

# Ejecutar el menÃº
if __name__ == "__main__":
    menu()

```

#### **ğŸ” ExplicaciÃ³n del CÃ³digo**

1. **`inicializar_archivo()`**
   - Crea el archivo `tareas.txt` si no existe.
2. **`agregar_tarea(tarea)`**
   - AÃ±ade una nueva tarea al archivo, marcÃ¡ndola como `Pendiente`.
3. **`listar_tareas()`**
   - Muestra todas las tareas guardadas en el archivo.
4. **`completar_tarea(numero)`**
   - Cambia el estado de una tarea de `Pendiente` a `Completada`.
5. **`eliminar_tarea(numero)`**
   - Borra una tarea especÃ­fica del archivo.
6. **`menu()`**
   - Muestra un menÃº interactivo para gestionar las tareas.

### ğŸ“”Persistencia de datos CSV

#### **ğŸ“Œ Ejercicio: GestiÃ³n de Contactos**

Crea un programa en Python que permita:

1. **Agregar contactos** con nombre, telÃ©fono y correo electrÃ³nico.
2. **Listar los contactos** guardados en el archivo `contactos.csv`.
3. **Buscar un contacto** por nombre.
4. **Eliminar un contacto** por nombre.

------

##### **ğŸ“œ CÃ³digo Base**

```python
import csv
import os

# Nombre del archivo CSV
ARCHIVO_CSV = "contactos.csv"

# FunciÃ³n para verificar si el archivo CSV existe, si no, lo crea con encabezados
def inicializar_archivo():
    if not os.path.exists(ARCHIVO_CSV):
        with open(ARCHIVO_CSV, mode="w", newline="", encoding="utf-8") as archivo:
            escritor = csv.writer(archivo)
            escritor.writerow(["Nombre", "TelÃ©fono", "Email"])

# FunciÃ³n para agregar un contacto
def agregar_contacto(nombre, telefono, email):
    with open(ARCHIVO_CSV, mode="a", newline="", encoding="utf-8") as archivo:
        escritor = csv.writer(archivo)
        escritor.writerow([nombre, telefono, email])
    print(f"âœ… Contacto {nombre} agregado correctamente.")

# FunciÃ³n para listar contactos
def listar_contactos():
    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        contactos = list(lector)

    if len(contactos) <= 1:
        print("ğŸ“‚ No hay contactos almacenados.")
    else:
        print("\nğŸ“œ Lista de contactos:")
        for i, contacto in enumerate(contactos[1:], start=1):  # Saltar encabezado
            print(f"{i}. {contacto[0]} - {contacto[1]} - {contacto[2]}")

# FunciÃ³n para buscar un contacto por nombre
def buscar_contacto(nombre):
    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        next(lector)  # Saltar encabezado
        for contacto in lector:
            if contacto[0].lower() == nombre.lower():
                print(f"ğŸ” Contacto encontrado: {contacto[0]} - {contacto[1]} - {contacto[2]}")
                return
    print(f"âŒ Contacto '{nombre}' no encontrado.")

# FunciÃ³n para eliminar un contacto por nombre
def eliminar_contacto(nombre):
    contactos_actualizados = []
    contacto_eliminado = False

    with open(ARCHIVO_CSV, mode="r", encoding="utf-8") as archivo:
        lector = csv.reader(archivo)
        contactos_actualizados.append(next(lector))  # Guardar encabezado

        for contacto in lector:
            if contacto[0].lower() == nombre.lower():
                contacto_eliminado = True
            else:
                contactos_actualizados.append(contacto)

    if contacto_eliminado:
        with open(ARCHIVO_CSV, mode="w", newline="", encoding="utf-8") as archivo:
            escritor = csv.writer(archivo)
            escritor.writerows(contactos_actualizados)
        print(f"ğŸ—‘ï¸ Contacto '{nombre}' eliminado correctamente.")
    else:
        print(f"âŒ Contacto '{nombre}' no encontrado.")

# FunciÃ³n principal para el menÃº interactivo
def menu():
    inicializar_archivo()
    while True:
        print("\nğŸ“ MenÃº de Contactos")
        print("1ï¸âƒ£ Agregar contacto")
        print("2ï¸âƒ£ Listar contactos")
        print("3ï¸âƒ£ Buscar contacto")
        print("4ï¸âƒ£ Eliminar contacto")
        print("5ï¸âƒ£ Salir")
        opcion = input("Selecciona una opciÃ³n: ")

        if opcion == "1":
            nombre = input("Nombre: ")
            telefono = input("TelÃ©fono: ")
            email = input("Email: ")
            agregar_contacto(nombre, telefono, email)
        elif opcion == "2":
            listar_contactos()
        elif opcion == "3":
            nombre = input("Ingresa el nombre a buscar: ")
            buscar_contacto(nombre)
        elif opcion == "4":
            nombre = input("Ingresa el nombre del contacto a eliminar: ")
            eliminar_contacto(nombre)
        elif opcion == "5":
            print("ğŸ‘‹ Saliendo del programa...")
            break
        else:
            print("âŒ OpciÃ³n invÃ¡lida. IntÃ©ntalo de nuevo.")

# Ejecutar el menÃº
if __name__ == "__main__":
    menu()
```

------

##### **ğŸ’¡ ExplicaciÃ³n del CÃ³digo**

1. ğŸ“‚ **Crea un archivo CSV si no existe**, con encabezados (`Nombre`, `TelÃ©fono`, `Email`).
2. â• **Agrega contactos** escribiÃ©ndolos en el archivo CSV.
3. ğŸ“„ **Lista los contactos** leyÃ©ndolos del archivo CSV.
4. ğŸ” **Busca un contacto** comparando el nombre ingresado con los datos guardados.
5. âŒ **Elimina un contacto** reescribiendo el archivo sin el contacto seleccionado.
6. ğŸ–¥ï¸ **MenÃº interactivo** que permite elegir entre las diferentes opciones.

## ğŸ“”Persistencia de datos JSON

Modulo corefiles.py

```python
import os
import json
from typing import Dict, List, Optional

def read_json(file_path: str) -> Dict:
    """Lee y retorna el contenido del archivo JSON"""
    try:
        with open(file_path, "r", encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}

def write_json(file_path: str, data: Dict) -> None:
    """Escribe datos en el archivo JSON"""
    with open(file_path, "w", encoding='utf-8') as file:
        json.dump(data, file, indent=4)

def update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None:
    """
    Actualiza datos en el JSON, opcionalmente en una ruta especÃ­fica
    Ejemplo: update_json('db.json', {'nuevo': 'dato'}, ['ruta', 'subruta'])
    """
    current_data = read_json(file_path)
    
    if not path:
        current_data.update(data)
    else:
        current = current_data
        for key in path[:-1]:
            current = current.setdefault(key, {})
        if path:
            current.setdefault(path[-1], {}).update(data)

    write_json(file_path, current_data)

def delete_json(file_path: str, path: List[str]) -> bool:
    """
    Elimina datos en la ruta especificada
    Retorna True si se eliminÃ³ exitosamente
    """
    data = read_json(file_path)
    current = data

    for key in path[:-1]:
        if key not in current:
            return False
        current = current[key]

    if path and path[-1] in current:
        del current[path[-1]]
        write_json(file_path, data)
        return True
    return False

def initialize_json(file_path: str, initial_structure: Dict) -> None:
    """
    Inicializa el archivo con una estructura base si no existe
    """
    if not os.path.isfile(file_path):
        write_json(file_path, initial_structure)
    else:
        current_data = read_json(file_path)
        for key, value in initial_structure.items():
            if key not in current_data:
                current_data[key] = value
        write_json(file_path, current_data)
```

main.py

```python
import corefiles as cf
import json

# InicializaciÃ³n
DB_FILE = "database.json"

def menu_principal():
    while True:
        print("\nğŸ¯ SISTEMA DE GESTIÃ“N ACADÃ‰MICA")
        print("1. Gestionar Campers")
        print("2. Gestionar Rutas")
        print("3. Ver datos")
        print("4. Salir")
        
        opcion = input("\nSeleccione una opciÃ³n: ")
        
        if opcion == "1":
            menu_campers()
        elif opcion == "2":
            menu_rutas()
        elif opcion == "3":
            mostrar_datos()
        elif opcion == "4":
            print("Â¡Hasta luego! ğŸ‘‹")
            break
        else:
            print("âŒ OpciÃ³n invÃ¡lida")

def menu_campers():
    while True:
        print("\nğŸ‘¥ GESTIÃ“N DE CAMPERS")
        print("1. Agregar camper")
        print("2. Editar camper")
        print("3. Eliminar camper")
        print("4. Volver al menÃº principal")
        
        opcion = input("\nSeleccione una opciÃ³n: ")
        
        if opcion == "1":
            id_camper = input("ID del camper: ")
            nombre = input("Nombre: ")
            edad = input("Edad: ")
            
            nuevo_camper = {
                id_camper: {
                    "nombre": nombre,
                    "edad": edad
                }
            }
            
            cf.update_json(DB_FILE, nuevo_camper, ["campers"])
            print("âœ… Camper agregado exitosamente")
            
        elif opcion == "2":
            id_camper = input("ID del camper a editar: ")
            datos = cf.read_json(DB_FILE)
            
            if id_camper in datos.get("campers", {}):
                print("\nDatos actuales:")
                print(f"Nombre: {datos['campers'][id_camper]['nombre']}")
                print(f"Edad: {datos['campers'][id_camper]['edad']}")
                
                nombre = input("\nNuevo nombre (Enter para mantener actual): ")
                edad = input("Nueva edad (Enter para mantener actual): ")
                
                camper_actualizado = {}
                if nombre:
                    camper_actualizado["nombre"] = nombre
                else:
                    camper_actualizado["nombre"] = datos['campers'][id_camper]['nombre']
                    
                if edad:
                    camper_actualizado["edad"] = edad
                else:
                    camper_actualizado["edad"] = datos['campers'][id_camper]['edad']
                
                cf.update_json(DB_FILE, camper_actualizado, ["campers", id_camper])
                print("âœ… Camper actualizado exitosamente")
            else:
                print("âŒ Camper no encontrado")
            
        elif opcion == "3":
            id_camper = input("ID del camper a eliminar: ")
            cf.delete_json(DB_FILE, ["campers", id_camper])
            print("ğŸ—‘ï¸ Camper eliminado exitosamente")
            
        elif opcion == "4":
            break
        else:
            print("âŒ OpciÃ³n invÃ¡lida")

def menu_rutas():
    while True:
        print("\nğŸ“š GESTIÃ“N DE RUTAS")
        print("1. Crear nueva ruta")
        print("2. Editar ruta")
        print("3. Agregar nivel a ruta")
        print("4. Eliminar ruta")
        print("5. Volver al menÃº principal")
        
        opcion = input("\nSeleccione una opciÃ³n: ")
        
        if opcion == "1":
            nombre_ruta = input("Nombre de la ruta: ")
            nueva_ruta = {
                nombre_ruta: {
                    "nivel1": {},
                    "nivel2": {},
                    "nivel3": {}
                }
            }
            cf.update_json(DB_FILE, nueva_ruta, ["rutas"])
            print("âœ… Ruta creada exitosamente")
            
        elif opcion == "2":
            nombre_ruta = input("Nombre de la ruta a editar: ")
            datos = cf.read_json(DB_FILE)
            
            if nombre_ruta in datos.get("rutas", {}):
                nivel = input("Nivel a editar (nivel1/nivel2/nivel3): ")
                
                if nivel in datos["rutas"][nombre_ruta]:
                    print("\nDatos actuales:")
                    nivel_actual = datos["rutas"][nombre_ruta][nivel]
                    if "trainer" in nivel_actual:
                        print(f"Trainer actual: {nivel_actual['trainer']}")
                    
                    nuevo_trainer = input("\nNuevo trainer (Enter para mantener actual): ")
                    
                    if nuevo_trainer:
                        info_nivel = {
                            "trainer": nuevo_trainer,
                            "estudiantes": nivel_actual.get("estudiantes", {})
                        }
                        cf.update_json(DB_FILE, info_nivel, ["rutas", nombre_ruta, nivel])
                        print("âœ… Ruta actualizada exitosamente")
                else:
                    print("âŒ Nivel no encontrado")
            else:
                print("âŒ Ruta no encontrada")
            
        elif opcion == "3":
            ruta = input("Nombre de la ruta: ")
            nivel = input("Nivel (nivel1/nivel2/nivel3): ")
            trainer = input("Nombre del trainer: ")
            
            info_nivel = {
                "trainer": trainer,
                "estudiantes": {}
            }
            
            cf.update_json(DB_FILE, info_nivel, ["rutas", ruta, nivel])
            print("âœ… Nivel agregado exitosamente")
            
        elif opcion == "4":
            ruta = input("Nombre de la ruta a eliminar: ")
            cf.delete_json(DB_FILE, ["rutas", ruta])
            print("ğŸ—‘ï¸ Ruta eliminada exitosamente")
            
        elif opcion == "5":
            break
        else:
            print("âŒ OpciÃ³n invÃ¡lida")

def mostrar_datos():
    datos = cf.read_json(DB_FILE)
    print("\nğŸ“Š DATOS ACTUALES:")
    print(json.dumps(datos, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    estructura_inicial = {
        "campers": {},
        "rutas": {}
    }
    cf.initialize_json(DB_FILE, estructura_inicial)
    menu_principal()
```

### **1ï¸âƒ£ `read_json(file_path: str) -> Dict`**

ğŸ”¹ **Lee el archivo JSON y retorna su contenido como un diccionario**.
ğŸ”¹ Si el archivo no existe, devuelve `{}` (un diccionario vacÃ­o).

```
def read_json(file_path: str) -> Dict:
    """Lee y retorna el contenido del archivo JSON"""
    try:
        with open(file_path, "r", encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}
```

âœ… **Ejemplo de uso**:

```
data = read_json("datos.json")
print(data)
```

Si `datos.json` contiene:

```
{
    "nombre": "Juan",
    "edad": 25
}
```

Salida:

```
{'nombre': 'Juan', 'edad': 25}
```

------

### **2ï¸âƒ£ `write_json(file_path: str, data: Dict) -> None`**

ğŸ”¹ **Escribe un diccionario en un archivo JSON**, sobrescribiendo el contenido.

```
def write_json(file_path: str, data: Dict) -> None:
    """Escribe datos en el archivo JSON"""
    with open(file_path, "w", encoding='utf-8') as file:
        json.dump(data, file, indent=4)
```

âœ… **Ejemplo de uso**:

```
write_json("datos.json", {"usuario": "Pedro", "edad": 30})
```

Esto generarÃ¡ un archivo `datos.json` con:

```
{
    "usuario": "Pedro",
    "edad": 30
}
```

------

### **3ï¸âƒ£ `update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None`**

ğŸ”¹ **Actualiza datos dentro del JSON**, ya sea globalmente o en una ruta especÃ­fica.
ğŸ”¹ Si `path` es `None`, actualiza la raÃ­z.
ğŸ”¹ Si `path` tiene una lista de claves, actualiza solo esa parte.

```
def update_json(file_path: str, data: Dict, path: Optional[List[str]] = None) -> None:
    """
    Actualiza datos en el JSON, opcionalmente en una ruta especÃ­fica
    Ejemplo: update_json('db.json', {'nuevo': 'dato'}, ['ruta', 'subruta'])
    """
    current_data = read_json(file_path)
    
    if not path:
        current_data.update(data)
    else:
        current = current_data
        for key in path[:-1]:
            current = current.setdefault(key, {})
        if path:
            current.setdefault(path[-1], {}).update(data)

    write_json(file_path, current_data)
```

âœ… **Ejemplo 1 (Actualizar la raÃ­z del JSON)**:

```
update_json("datos.json", {"telefono": "123456789"})
```

Si `datos.json` tenÃ­a:

```
{
    "usuario": "Pedro",
    "edad": 30
}
```

Ahora tendrÃ¡:

```
{
    "usuario": "Pedro",
    "edad": 30,
    "telefono": "123456789"
}
```

âœ… **Ejemplo 2 (Actualizar un valor dentro de una estructura anidada)**:

```
update_json("datos.json", {"ciudad": "BogotÃ¡"}, ["direccion"])
```

Si `datos.json` era:

```
{
    "usuario": "Pedro",
    "direccion": {}
}
```

DespuÃ©s de la actualizaciÃ³n:

```
{
    "usuario": "Pedro",
    "direccion": {
        "ciudad": "BogotÃ¡"
    }
}
```

------

### **4ï¸âƒ£ `delete_json(file_path: str, path: List[str]) -> bool`**

ğŸ”¹ **Elimina datos dentro del JSON en una ruta especÃ­fica**.
ğŸ”¹ Retorna `True` si se eliminÃ³ correctamente, `False` si la clave no existe.

```
def delete_json(file_path: str, path: List[str]) -> bool:
    """
    Elimina datos en la ruta especificada
    Retorna True si se eliminÃ³ exitosamente
    """
    data = read_json(file_path)
    current = data

    for key in path[:-1]:
        if key not in current:
            return False
        current = current[key]

    if path and path[-1] in current:
        del current[path[-1]]
        write_json(file_path, data)
        return True
    return False
```

âœ… **Ejemplo de uso**:

```
delete_json("datos.json", ["direccion", "ciudad"])
```

Si `datos.json` tenÃ­a:

```
{
    "usuario": "Pedro",
    "direccion": {
        "ciudad": "BogotÃ¡",
        "codigo_postal": "110111"
    }
}
```

DespuÃ©s de la eliminaciÃ³n:

```
{
    "usuario": "Pedro",
    "direccion": {
        "codigo_postal": "110111"
    }
}
```

Si la clave no existe, la funciÃ³n devuelve `False`.

------

### **5ï¸âƒ£ `initialize_json(file_path: str, initial_structure: Dict) -> None`**

ğŸ”¹ **Crea un archivo JSON con una estructura inicial si no existe**.
ğŸ”¹ Si ya existe, verifica si faltan claves y las agrega sin modificar los datos existentes.

```
def initialize_json(file_path: str, initial_structure: Dict) -> None:
    """
    Inicializa el archivo con una estructura base si no existe
    """
    if not os.path.isfile(file_path):
        write_json(file_path, initial_structure)
    else:
        current_data = read_json(file_path)
        for key, value in initial_structure.items():
            if key not in current_data:
                current_data[key] = value
        write_json(file_path, current_data)
```

âœ… **Ejemplo de uso**:

```
initialize_json("datos.json", {"usuarios": {}, "config": {"modo": "oscuro"}})
```

Si `datos.json` no existe, se crea con:

```
{
    "usuarios": {},
    "config": {
        "modo": "oscuro"
    }
}
```

Si `datos.json` ya existÃ­a con:

```
{
    "usuarios": {
        "Juan": {"edad": 25}
    }
}
```

DespuÃ©s de `initialize_json()`, se actualizarÃ¡ a:

```
{
    "usuarios": {
        "Juan": {"edad": 25}
    },
    "config": {
        "modo": "oscuro"
    }
}
```

ğŸ”¹ La clave `"usuarios"` no se modifica porque ya existÃ­a.
ğŸ”¹ Se agrega `"config"` porque no estaba presente.

------

## **ğŸ“Œ Resumen del CÃ³digo**

| **FunciÃ³n**                                     | **DescripciÃ³n**                                          |
| ----------------------------------------------- | -------------------------------------------------------- |
| `read_json(file_path)`                          | Lee un JSON y lo retorna como diccionario.               |
| `write_json(file_path, data)`                   | Escribe datos en un JSON, sobrescribiÃ©ndolo.             |
| `update_json(file_path, data, path)`            | Actualiza datos en una ruta especÃ­fica del JSON.         |
| `delete_json(file_path, path)`                  | Elimina datos en una ruta especÃ­fica del JSON.           |
| `initialize_json(file_path, initial_structure)` | Inicializa un JSON con una estructura base si no existe. |
